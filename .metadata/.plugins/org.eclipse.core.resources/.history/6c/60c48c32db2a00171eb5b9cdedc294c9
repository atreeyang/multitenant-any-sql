MySQL approach to achieve multitenancy is to add a column to every table that hold tenant data and create a view on the table that gets the tenant from a session variable that is set by the MySqlSessionVariableTenantSessionCallback.
 for eg. In a web application the tenantId could should be set after validating the user credentials and knowing the tenant of the user.
 {code}
 
 CREATE TABLE tbl_person ( tenant int NULL,  id int(100) NOT NULL,  name varchar(256) NOT NULL,  age number(256) NOT NULL,  last_updated timestamp DEFAULT now() NOT NULL,  date_created timestamp DEFAULT now() NOT NULL ) ;
CREATE TRIGGER before_insert_tbl_person BEFORE INSERT ON tbl_person FOR EACH ROW SET new.tenant = gettenant();
CREATE TRIGGER before_update_tbl_person BEFORE UPDATE ON tbl_person FOR EACH ROW SET new.last_updated = now();
ALTER TABLE tbl_person ADD CONSTRAINT ct_primarykey PRIMARY KEY CLUSTERED ( tenant, id );
CREATE OR REPLACE VIEW person ( id,  name,  age,  last_updated,  date_created ) AS SELECT  tbl_person.id,  tbl_person.name,  tbl_person.age,  tbl_person.last_updated,  tbl_person.date_created from tbl_person where (tbl_person.tenant = gettenant());
 
 
 You could use the schema mysql generation tool to generate the table, 
 //TODO : Link to schema readme.md
 
 sample schema xml looks like below, produces the ddl above.
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<database xmlns="http://www.analogyx.com/schemer/domain">
	<table name="person">
		<column name="id" nullable="false" type="int" scale="100"/>
		<column name="name" nullable="false" type="string" scale="256"/>
		<column name="age" nullable="false" type="number" scale="256" />
		<index primary="true">
			<on>id</on>
		</index>
	</table>
</database>
	
 {code}
 
 sql function to get the tenant from session variable is 
 {code}
 	CREATE FUNCTION gettenant() RETURNS INT 
	BEGIN
		RETURN @tenant;
	END
 {code}
 
 Once the tables and  are created, you can test it by 
 
 set @tenant=1
 insert into user(
